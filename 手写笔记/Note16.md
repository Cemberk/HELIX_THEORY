# 小鸟生存演示(下)-势

***

<!-- TOC -->

- [小鸟生存演示(下)-势](#%E5%B0%8F%E9%B8%9F%E7%94%9F%E5%AD%98%E6%BC%94%E7%A4%BA%E4%B8%8B-%E5%8A%BF)
  - [n16p1 内类比中mv基本模型的支持](#n16p1-%E5%86%85%E7%B1%BB%E6%AF%94%E4%B8%ADmv%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81)
  - [n16p2 实与虚2](#n16p2-%E5%AE%9E%E4%B8%8E%E8%99%9A2)
  - [n16p3 内类比迭代之祖母的嵌套](#n16p3-%E5%86%85%E7%B1%BB%E6%AF%94%E8%BF%AD%E4%BB%A3%E4%B9%8B%E7%A5%96%E6%AF%8D%E7%9A%84%E5%B5%8C%E5%A5%97)
  - [n16p4 继续迭代v1.1的决策循环](#n16p4-%E7%BB%A7%E7%BB%AD%E8%BF%AD%E4%BB%A3v11%E7%9A%84%E5%86%B3%E7%AD%96%E5%BE%AA%E7%8E%AF)
  - [TODOLIST](#todolist)

<!-- /TOC -->

***

## n16p1 内类比中mv基本模型的支持
`CreateTime 2019.03.22`

> 内类比中,所有构建的fo亦需遵守mv基本模型 (`fo<=>mv互指向`);

| mv在he中的流程简图 >> |
| --- |
| ![](assets/99_mv在he中的流程简图.png) |
| 1. 分布在全网的网络强度为静; |
| 2. 作为指引的mv节点为动; |
| Q: 意识流双序列中,强度序列本由mv的动转静转化而来,那么时间序列是否受mv影响? |
| 注: 关于mv影响关联强度,参考17年10月文:[《he4o神经网络》](https://zhuanlan.zhihu.com/p/30320128) |

| absMv的融合方式 >> |
| --- |
| **值的融合 >>** |
| > `mv中以迫切度和delta数来表示信息,所以可以通过简单的计算来融合;如下两种:` |
| 1. 求和平均 `将采用` |
| 2. 相对取小 `正采用` |
|  |
| **标识的融合 >>** |
| 1. 当conMvArr抽象absMv时,所有具象arr中,标识一致则继用,不一致,则用"mvNone"标识; |

| 求和平均 >> |
| --- |
| 1. 关联强度决定,mv融合时的比重系数; (暂不实现) |
| 2. 采用原因: 因为内类比的联想以"动微信息"为源,所以会导致mv有正有负;取min则容易导致,所有absMv皆为负情绪; |
| 如: (aMv=2 & bMv=1) = 融合后为1.5; |
| 如: (aMv=3 & bMv=0 & a强度=2 b强度=1) = 融合后为2; |
| 注: 关联强度的运算方式: 如aMv将被抽象,他的强度为aMv.conPorts中前3位的strong求平均; |
| 注: 第1条暂不实现原因: 我们目前都以计数器方式在做,改动较大,以后再改; |


<br><br><br><br><br>

## n16p2 实与虚2
`CreateTime 2019.03.26`

| 前言 >> |
| --- |
| 1. 在note15中,我们得到最具象即真实,但有时最具象还未存在,需要去寻找; |
| 2. 此时我们需要借助fo来联想查找之; |

| 简介 >> |
| --- |
| 1. 我们需要让小鸟知道树会掉坚果; (带皮) |

| 得到真实坚果的方法 >> | 选用 |
| --- | --- |
| 方法1. 祖母中,先抽象,后最具象,找到坚果; | 75% |
| 方法2. 先微信息,再局部匹配不同的坚果; | 5% |
| 方法3. 先时序,doChange找到坚果出现的时序; (可解决,最具象需要寻找) | 80% |

> ###### 坚果的发现步骤:
> 1. 对于`坚果祖母`的引用,可以联想到抽象的fo;
> 2. 从此抽象fo中,可以得到`坚果树`->`坚果`的时序;
>
> ###### 饭的发现步骤:
> 1. 对于`饭`的引用,可以联想到抽象的fo;(做饭)
> 2. 从此抽象fo中,可以得到`做`->`饭`的时序;
>
> ###### 问题:
> 1. 有些真实源于寻找或创造(fo),有些源于大脑(alg最具象);
> 2. 我们是否可以脱离了fo而找到真实的祖母?

| 深入思考 >> |  |
| --- | --- |
| 图1 | ![](assets/100_虚与实的祖母时序协作.png) |
| 解析 | 虚实与本质上是祖母与时序的协作问题; |
|  |  |
| 图2 | ![](assets/101_虚与实的动.png) |
| 解析 | 本质上是虚与实的动->祖母的 `产生` 与 `消失` 问题; |
| 解析2 | 在时序中,A->B->C,前面导致后面,B在A后产生,又在C前消失; |
| 解析3 | 所以,产生与消失是伪命题,解决了mv即为实; |
| 例如: | 信宗教的人,念阿弥陀佛解决了心理问题,会认为佛教有用; |
|  |  |
| 矛盾点: | 我们不能吃昨天的饭; (最具象被消费掉) |
| 矛盾解析: | 我们可以固定去工具箱拿剪刀,每次如此,尽管每次都拿走了; |
| 结果 | 结果见下表; |

| 思考结果 >> |  |
| --- | --- |
| TITLE | 虚与实,在于he自己愿意相信它为实,或虚; |
| DESC | 虚与实是伪命题,本质是mv的反馈强化学习,在决策中作用于评价; |
| 新问题 | 为什么在`吃->坚果`中,`吃`没有导致出现`坚果`; |
|  | 而`做->饭`,`做`却导致出现`饭`; |
|  | `吃饭` 和 `做饭` 的区别; |
| 新问题2 | mv的反馈强化能否融入到mv基本模型,是否有什么异同? |
| A2 | 此问题与本题无关; |
| 新问题3 | 是否需要对外类比进行迭代,以更好的支撑决策? |

| 解决方案1 >> | `做饭` 和 `吃饭` 的区别问题 |
| --- | --- |
|  | **祖母的嵌套,比如:空间中有坚果** |
| 1说明 | 此时,在内类比中,子祖母作为微信息的变化; |
| 1分析 | 要想类比,必然有信息可比,饭的子信息是缺失的,那么,找父信息,如何确定父祖母呢? -> 如:`做饭`,`说话` ->`转至n16p3` |
| 结果 | 采用,嵌套本质是信息嵌套,祖母嵌套,与空间无关; |

| 解决方案2 | **`A->B->C`时序,前导致后;** |
| --- | --- |
| 2说明 | 每一个元素都在前一个后`出现`,且在后一个前`消失` |
| 2结果 | 错误,吃饭并没有导致饭出现; |
| 2说明 | 前导致后,但后一直存在; |
| 结果 | 方案2废弃,因为跑题; |

| 解决方案3 | **空壳祖母 & 实壳祖母** |
| --- | --- |
| 3说明 | 0信息,本身也是信息; |
| 3采用问题 | 如果采用了祖母嵌套,那么无需要再采用空壳祖母 |
| 结果 | 方案3废弃,因为有了更加正确的祖母嵌套方案; |

| 解决方案4 | **内类比扩展 + 抽具象实现祖母嵌套** |
| --- | --- |
| 4说明 | 将微信息的不同数扩展为n个,并支持祖母嵌套中,祖母的消失变化; |
| 4Q | 祖母嵌套是否需要支持`主动视觉`呢? |
| A | 如果,可以将坚果与皮识别为嵌套两个祖母;那就不用主动视觉; |
| 4问题 | 是否抽象具象,可以替代祖母嵌套呢? |
| A | 实质上是,具象中的values中,应该不应该以相同的祖母来替换那部分信息量;如:`a3=(a,b,c)`那么`a,b,c,d`节点,用不用改为`a3,d` |
| A | 所以,理论上,这一块应该被替换,采用率90% |
| 结果 | 采用,先祖母嵌套,后内类比扩展进行支持;详情转`n16p3` |

> 问题: 为什么眼见为实?
> * 正向反馈,愿意相信眼见为实;

> 换个方向: `absFo吃饭` 的具象时序 `con1做饭吃`/`con2买饭吃`;
> * 正向反馈,愿意相信,做饭能吃饱;


> #### 方案2: 祖母的嵌套方案 >>
> 原则:
> 1. 我们要尽量将祖母嵌套问题,作为一个系统性的问题,来自然而然的过程;
> 2. 比如: 思维控制器,在构建时,则具有此嵌套结构;
> 3. 要通过几个实例的内省,来互相印证一下,提高此方案的可信度;
> 4. 在认知升级,组分循环中,又有多少微信息可以独当一面呢?几乎都是祖母吧;
> 5. 隐性的场景,***祖母中不注意到的信息;***
> 5. 嵌套非强制,所以此方案***作废***;

| 如何嵌套的确定父信息 >> |
| --- |
| 1. 将`没饭的厨房` 做成 `有饭的厨房`; |
| 2. `祖母的嵌套` 能解决所有的 `虚与实` 的问题吗? |
| 如: `厨房做饭` `公司点外卖` `饭店买饭` `在家吃饭` `等午饭` |
| 白话描述: 在 `xx` 出现了 `xx` |
| 如:在`周围`出现了声音,在`厨房`做出了饭,在`那儿`掉下了坚果; |

> #### 4. 内类比扩展
> 1. 坚果 + 皮 = 2个祖母嵌套;
> 2. 当汽车给坚果去皮 -> 内类比,发现 `皮` 消失;


<br><br><br><br><br>


## n16p3 内类比迭代之祖母的嵌套
`CreateTime 2019.03.29`

> 1. 描述：实与虚的问题,最终变成了祖母嵌套的问题;
> 2. 本质：其实本质上是类比构建`祖母的有和无`;
> 3. 白话：说白了,是物质欲望的问题;
> 4. 实践：此处通过网络结构与mv基本模型,来表达出了物质欲望的成因与作用;

| 内类比迭代之祖母的嵌套 >> |
| --- |
| ![](assets/102_内类比迭代之祖母的嵌套.png) |
| 1. 原本内类比仅支持是祖母的变化,而有了祖母嵌套,可支持`祖母的有无`; |
| 2. 变化公式为:`a1->a2` 得出 `1-2变大` |
| 3. 有无公式为:`algA(a0a1)->algB(a0null)` 得出 `a1消失` |
| 有无白话描述：一个由坚果肉和皮组成的祖母,当变为无皮坚果时,我们会认为皮不见了; |

| 祖母嵌套所导致的问题 >> |
| --- |
| 1. 视觉惯性与思维固化; |
| ![](assets/103_视觉惯性与思维固化示图.png) |
| 解释1: 当从类似上图上,我们看到兔子时,下次会再惯性看到兔子; |
| 解释2: 类似,其它视觉之外的思维,也是如此; |

| 代码步骤 >> |  |
| --- | --- |
| 1 | 构建抽象祖母时,将absAlg的pointer替换到conA和conB中的相应values处; |
| 2 | 内类比中,扩展支持values中,abs_p类型的类比(即有和无) |
| 3 | 构建相关的:`有无祖母`,`导致有无的时序`等,参考下表 |

| 有无祖母构建表 >> |
| --- |
| 1. 将`有无祖母`的值,采用cLess表示无,cGreater表示有; |
| tips: 尝试将`有无祖母`与`变化祖母`使用同一处理方式; |
| TODO: 去代码中,检查alg采用的标识,(建议采用自增唯一标识符); |

> **变化:** 使用同一标识下,值的变化,来类比;  
> **有无:** 使用(祖母标识)下,关于类比时的,标识判定问题?是否需要标识相同?  

* Q1: 内类比有无时,需要标识一致吗?  
  - A1: 不限于标识,对其values进行类比; (限values中微信息的标识);


* Q2: 祖母嵌套的根,根是什么?这个模糊的根需要做什么处理吗?不会影响各正常功能吧?
  - A2: 从模糊的根部,其实我们也得不到抽象之外什么有效的东西;所以,不必处理,不会影响;


* Q3: 为什么抽象祖母时,abs_p要替换到conA的相应values处?
  - A3: 因为思维必然要构建,要么就采用此方案,要么构建一个`v1v2a3`这样的中间祖母,上抽象指向`a3`,下具象指向`v1v2v3`;


* Q4: `有无祖母`如何知识表示?
  - A4: 可以由cHav和cNone来表示有和无;

| 有无的构建和知识表示 >> |
| --- |
| ![](assets/103_有无的构建和知识表示.png) |
| 1. 构建部分,暂放一放,因为依赖知识表示部分的解决; |
| 2. 知识表示: |
| > 知识表示难点: `有`和`无`在哪表示; |
| >> 难点解决解决: 采用与`cLessGreater同样的方法`: 当我们联想到algA,找他的cHav问题时,想根据algA_p和cHav找到微信息,然后找引用祖母,此时,此祖母就是algA为实的祖母;然后此cHavAlgA与algA抽具象关联着; |
| > 知识表示方案: 独立`动祖母`模块; |
| >> 此方案,在以后版本中,再使用,此时虽正确,但时机不够成熟; |

| 有无的知识表示与构建步骤示图 >> |
| --- |
| ![](assets/104_有无的知识表示与构建步骤.png) |
| 说明: 四个区: `微信息区`,`分为alg区`,`fo区`,`mv区`; |
| 1. aA祖母中,a0抽象时的嵌套,即将a0_p替换到aA的values中; |
| 2. 构建流程从`aA->x->aB`的内类比发现`a0消失`开始; |
| 3. 微信息中,以a0的指针转字符串: `a0_p.str为标识` + `cNone为值`; |
| 注: 图中abs为抽象关联,ref为引用关联; |

| QA >> |
| --- |
| **Q1: 在内类比中,支持多个微信息的不同;** |
| A1: 目前不需要; |
| **Q2: 非连续微信息的嵌套问题,如`a,b,c,d,e,f,g`类比`a,b,w,d,e`;** |
| A2:目前祖母外类比,仅支持非连续的单一sames结果,所以不存在多个的问题,absAlg(abef),conAlgA(abef,w)和conAlgB(abef,c,d,g); |
| **Q3: 是否可废弃祖母嵌套?** |
| A3:99%否; |
| **Q4: 因为...所以...的嵌套问题** |
| A4:用时序解决; |


```java
//内类比中祖母的无 >>
1. 时序(Alg1 Alg2 Alg3)
2. Alg1(1,2,3,Alg4)
3. Alg3(1,2,3)

>> 结果: 在时序中,从Alg1到Alg3中,Alg2导致了Alg4的消失)
```

| 祖母A变成祖母B示图 >> |
| --- |
| ![](assets/105_祖母A变成祖母B示图.png) |
| 1. 马里奥进入管道,后变成一坨屎; |
| 2. 我们通过时序内类比,发现了马里奥变屎,并抽象; |
| 3. 抽象信息方面:`我们会认为这坨屎成为玩家;` |
| 4. 具象信息方面:`这坨屎会跳的话,我们不会奇怪;` |


<br><br><br><br><br>


## n16p4 继续迭代v1.1的决策循环
`CreateTime 2019.04.11`

> 以上已解决`大`,`小`,`有`,`无`的问题,所以此处回归到决策循环,继续从algScheme来解决祖母的判定,和最终输出到actionScheme行为;

| 代码步骤 >> | (发现->距离->飞行) |
| --- | --- |
| 1. | 找到坚果,由有无时序来解决"有无"问题; `cNone,cHav` (有无) |
| 2. | 找到的坚果与fo中进行类比; `找出距离不同,或带皮的不同` `cLess,cGreater` (变化) |
| 3. | 将距离与带皮转化成行为,条件的行为化; `如飞行,或去皮` `actionScheme` (行为) |



<br><br><br><br><br>


## TODOLIST

| TODO >> | DESC | STATUS |
| --- | --- | --- |
| 1 | 标识映射,(解析和反解析的map,可以采用36进制的字符串;) |  |
| 2 | 性能优化_设计节点收集器,总操作完成后,由丘脑统一持久化; |  |
| 3 | 做意识流双序列; |  |
| 4 | 代码结构优化_将不应期,使用字典实现; |  |
| 5 | 代码中检查alg采用的标识,(建议采用自增唯一标识符); |  |
| 6 | cLess,cGreater,cHav,cNone有可能后天导致溢出碰撞,所以,要采用别的设计来避免此问题; |  |
| 7 | 关于精度的范围匹配问题,应该在祖母层后天完成;但不影响小鸟核心智能演示,所以可暂使用一些算法层实现 (比如方向精度为10); |  |
| 8 | 考虑ThinkOut在fo或mv之上的层,才会回归到dataIn来总循环,而更下层,则仅在适应局部层数间循环; |  |
| 9 | 将AlgNode.refPorts改为单文件方式; |  |


```
//TIME:20190226
/////1. TODOTOMORROW:做意识流双序列;

//1. 首先是要解决强度序列之外的再加时间序列的问题; (其实不是时间序列,仅是一个激活节点的内存缓存)
//2. 使用XGRedis来做10分钟自动销毁;
//3. 事务需求:
//4. 比如我们需要搜索硬盘节点中,哪个port指向的节点在redis中;
//5. 再比如: 我们需要搜索到哪个redis中的node具有某微信息; (性能优化,建内存索引)
```


<br><br><br><br><br>
