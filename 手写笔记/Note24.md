# 防撞训练

> 注:
> 1. 在n23中,已经由子任务测试到GL了,但GL还没完全跑顺当;

> 名词解析:
> 1. OVM : ToValueModel
> 2. 稳定性: 是指经验的效用,有效率;

***

<!-- TOC -->

- [防撞训练](#防撞训练)
  - [n24p01 GL行为化迭代](#n24p01-gl行为化迭代)
  - [n24p02 AIKVPointer集成type迭代](#n24p02-aikvpointer集成type迭代)
  - [n24p03 单元测试-自检告警机制](#n24p03-单元测试-自检告警机制)
  - [n24p04 子任务迭代](#n24p04-子任务迭代)
  - [n24p05 十二测:继续进行GL相关测试训练](#n24p05-十二测继续进行gl相关测试训练)
  - [n24p06 IRT的理性失效](#n24p06-irt的理性失效)
  - [n24p07 PM迭代V4-稳定性判断 (理性迭代)](#n24p07-pm迭代v4-稳定性判断-理性迭代)

<!-- /TOC -->

## n24p01 GL行为化迭代
`CreateTime 2021.09.09`

本节针对GL行为化与PM中关于GL相关进行不应期迭代;

| 24011 | 迭代项 |
| --- | --- |
| 迭代1 | 对PM生成toValueModel做防重,以防止一模一样的OVM多次GL行为化; |
| 迭代2 | 对PM中找修正GL的目标:`glValue4M`,做不应期,比如G不行就L试下; |

| 24012 | GL体用协作问题 `参考:23229-方案3` |
| --- | --- |
| 问题 | 1. 表现为在FZ22重新训练中,很难抽象出[飞方向,木棒]的节点; |
|  | 2. 内类比生成了许多Y距GL经验,但在getGL中却取不到一条适合修正用的; |
| 分析 | 分析当前代码做法: |
| 1. 体 | 内中外类比现在的assFo是以取absRFos与其具象得出; |
|  | > 具象混乱(因为它可能与当前protoFo无关系) & 抽象失真(absRFo太抽象); |
|  | > 导致很难抽象出[飞方向,木棒],且识别时也没法识别到[飞方向,木棒]; |
|  | 原则: 认知期,抽象优先`absRFos`,照顾具象`matchRFos`; |
| 2. 用 | getGL现在的curMasks是仅取absRFos来得出; |
|  | > 问题: absRFos太抽象,而gl又少又抽象,稳定性极差; |
|  | > 考虑改为matchRFos与其抽象取GL经验 (从稳定找普适); |
|  | 原则: 决策期,具象优先`matchRFos`,延展抽象`matchRFos.absPorts`; |
|  | 延展: matchRFos有匹配度,如有问题可考虑加入cutIndex实现精准控制; |
| 实践 | 通过前面分析1,2中的原则,来制定代码迭代; |
| 1. 体 | ![](assets/529_内中外类比assFo联想示图迭代.png) |
| 2. 用 | ![](assets/530_getInnerGL经验联想示图.png) |
| 结果 | 将`体`改为absRFos+matchRFos后,发现永远取不到assGLFo `转至24013` |

| 24013 | GL到absGL未冷启问题 `T` |
| --- | --- |
| 问题 | 见24012结果,gl一直停留在最具象,没有向抽象寸进,导致assGLFo总为0条; |
| 分析 | 1. 在构建absRFos时,没有做任何GL抽象操作; |
|  | 2. 在内中外类比v5中,absRFos和matchRFos也都是抽象的,全没GL嵌套; |
| 方案1 | 内中外类比中,应对首条seemFo(相似非全含fo)做支持,完成gl抽象起步; |
|  | 内中外类比中,应对首条seemFo进行外类比; |
| 方案2 | 或直接用matchRFos.conPorts作为seemFo `即回滚到原v4代码` |
|  | 此时seemFo外类比就不用了,因为matchRFos就是它们的外类比抽象结果; |
| 选定 | 因为方案2比方案1更适用于内中外类比的`起步`,且与原v4一致,故选用; |
| 示图 | ![](assets/531_内中外类比回滚到v4并加入absRFo支持后示图.png) |
| 结果 | 如图,代码回滚到v4,且改为支持absRFos,后回测生成absGL正常了; |

| 24014 | 重训GL的体与用 | 步骤+结果 |
| --- | --- | --- |
| 1 | 重新进行`x向飞,直击`xN次; | 24015第1,2步,正常 |
| 2 | 看生成[x向,木棒]时序是否正常; | 24015第1,2步,正常 |
| 3 | 看[x向,木棒]下,能否正常构建嵌套gl; | FZ23-2日志,正常 |
| 4 | 看getInnerGL中,能否正常取到gl经验 | 非Y距取到了,Y距还没测 |

| 24015 | 训练步骤整理 | 训练目标 |
| --- | --- | --- |
| FZ23-1 | 边直击边飞至左下 | 被撞和不被撞经验,GL经验 |
| FZ23-2 | 边直击边飞至右上 | 被撞和不被撞经验,GL经验 |
| FZ23-3 | 在安全地带各处偏击10次 (危险地带下方) | 加训P经验 |
| FZ23-4 | 在危险地带各处直击10次 | 加训S经验 |

| 24016 | 抽象GL经验太少问题 `T` |
| --- | --- |
| 说明 | 在训练24015前两步时,发现抽象GL极少执行; |
| 方案 | 可尝试,将内中外类比的配置limit调高 (要广放少收); |
| 结果 | 把limit从3和2调整为5和5时,训练第2步抽象GL经验从1条变成6条,有效; |

| 24017 | 训练FZ23并测问题 |
| --- | --- |
| 复现 | 按24015训练得到FZ23,然后`FZ23,右下飞,直投`; |
| 问题1 | 全是`PM评价速0不通过,修正(速0->速233)`; |
|  | 分析: 其实速不重要,下帧会飞到哪才重要; |
|  | 方案1: 退方案,把速从视觉中去掉,速不重要,因为HE视觉本来就是离散的; |
|  | 方案2: 进方案,让HE认识到速不重要 `速并不需要修正,但每条P经验又都有` |
|  | > 所以每次P评价都有速,必须加工,但又其实没办法行为化解决它; |
|  | 结果: 先采用方案1,方案2提到的问题以后还会遇到,到时再说; |
| 问题2 | 性能问题,发现FZ23在训练中太卡了,内类比慢; |
|  | 分析: 内中外类比里的limit5,5,20三个参数再调下试试; |
|  | 重训1: 调整内中外类比Limit为:6,2,10,重训为FZ24 `略好些` `最终选定`; |
|  | 重训2: 调整内中外类比Limit为:2,2,10,重训为FZ25 `又好些`; |
|  | 结果: 调整值不能根本解决问题,卡是从GL学全开始的,即决策系统在卡; |
|  | 跟进: 分析决策系统卡的问题 (后再测,先改24018问题); |

| 24018 | 训练FZ24,FZ25并测问题 |
| --- | --- |
| 训练 | 按24017问题2重训`1,2`,得到`FZ24,FZ25` |
| 问题 | FZ24-2和FZ25-4,发现取GL时,绝大多数经验已被评过否; |
| 线索1 | 查最初空S构建日志`FZ24-2`,得出OPushM中mIsC可能失败,如下图: |
|  | ![](assets/532_24018大量有效GL经验被空S否掉原因.png) |
|  | 如图,A114与A266判定mIsC失败,导致OPushM失败,进一步NV查它俩关系; |
|  | 调试: ![](assets/535_24018线索2_抽具象关联NV查结果.png) |
|  | 说明: 示图有关联,打日志时没关联,可能是日志后很久又联上的; |
|  | 分析1: A114是刚构建TopAbs出来的,所以与旧有A266还没关联也正常; |
|  | 分析2: 示图说明后来也关联上了,当时还没学确切有此问题正常; |
|  | 分析3: 只是可惜这条GL经验被空S干掉了,比较冤枉; |
|  | 影响面: 此问题仅出现在未学习确切情况下,影响面不大; |
|  | 结果: 当时无关联正常,GL被冤枉干掉,不过影响面不大,以后再改吧; |
|  | TODO: 看来单条空S评否不合理,后改进之; |
| 线索2 | 查`FZ24-4`,得出GL可能取混乱,如下图: |
|  | ![](assets/533_24018可疑2_导致GL被大量空S掉.png) |
|  | 如图,可视化GL中的maskFo,看是否会混,为何会混; |
|  | 调试: `FZ24,右下,直击,右上,直击`,能取到F179,且X与Y距时,共同的F132; |
|  | ![](assets/534_24018线索2_GL经验混乱问题导致互相空S掉问题.png) |
|  | 如图,F179有许多GL经验,任一条,就测得其glConAlg竟同时是4个glAlg的具象; |
|  | 问题: 这样的话F119就可以用于解决`向大,X大,距小,Y距大`,互相空S掉; |
|  | 方案: 将atType集成到AIKVPointer中,并作用于alg防重,可以避免它混乱; |

| 24019 | glFo&glAlg防重不全面,导致空S混乱问题代码实践 |
| --- | --- |
| 说明 | 防重不全面,是因为未全面根据type和distanceY `转至n24p02`; |



<br><br><br>

## n24p02 AIKVPointer集成type迭代
`CreateTime 2021.09.19`

| 24021 | glFo&glAlg防重不全面,导致空S混乱问题代码实践 |
| --- | --- |
| 各类示图 | ![](assets/536_hnglsp节点取用区分判断方式不同分析.png) |
| 示图改1 | `GL下探在V,需要at&ds&type判别`,`而HNSPD仅在AF,type即可判别`; |
| 实践简介 | 需要将视觉属性名如`distanceY`和type如`G`集成到glConAlg中; |
| 套用实例 | 1. 将glConAlg赋值pointer.type & 并将distanceY赋值到ds; |
|  | 2. 将glFo赋值pointer.type & 并将distanceY赋值到ds; |
|  | 3. 仅GL时,需将`distanceY`赋值传递到A和F的ds下 (参考:示图改1); |
|  | 结果: 这样话,F179就会有四个不同的F119,分别各自被空S,避免彼此误伤; |
| 概念部分 | 1. 将所有的createAbsAlg_NoRepeat()新增type节点; `T` |
|  | 2. 将Same类型全改成ATDefault类型; `T` |
|  | 3. 构建glAlg时,将`distanceY`这些传递赋值到ds `T`; |
|  | 4. 构建glAlg时,将`FLY_RDS`这些传递赋值到at (因为有时没ds) `T`; |
| 时序部分 | 1. 将所有的createAbsFo_NoRepeat()新增type节点 `T`; |
|  | 2. 构建glFo时,将`distanceY`这些传递赋值到ds `T`; |
|  | 3. 构建glFo时,将`FLY_RDS`这些传递赋值到at (因为有时没ds) `T`; |
| 使用部分 | 1. 废弃dataSource和type互转,及所有调用代码 `T`; |
|  | 2. 废弃getHNGLConAlg_ps(),以及glConAlgs的包含判断代码; `T`; |
|  | > 联想GL经验路径早改为场景联想,现又改了vDS==fo.ds匹配判断; |
|  | 3. 在AINetUtils中取ports的众多方法中,用ds筛选改成用type筛选 `T`; |
|  | 4. 把所有生成AIKVPointer的方法,加上type参数 `T`; |

| 24022 | 迭代完回归测试 |
| --- | --- |
| BUG1 | glFo内中外类比,非末位alg类比构建absAlg时,使用Type=GL的问题 `T`; |
| BUG2 | 构建SFo时,at&ds竟有值,经查是从conNodes中取的,改为仅GL时才取 `T`; |
| BUG3 | 有时外类比构建absAlg时,两个conAlg不是同一类型,触发自检6 `T`; |
|  | > 原因1是构建SPFo时,收集的shortAlg为Default类型,而非SP类型导致; |
|  | > 原因2是alg构建器中,从conAlgs中防重没判断at&sp&type导致错乱; |
| BUG4 | FZ26-1训练中,发现H类型Fo中有S类型的Alg,触发自检6 `T`; |
|  | > 原因是在TIR_Alg识别中,取refPorts时没有筛选normal类型; |
| BUG5 | 因为ATSame和ATDiff导致TIR_Fo识别到Fos结果很少 `T`; |
|  | > 在TIR_Fo中,仅取normal结果,所以没包含ATSame和ATDiff; |
|  | > 将这俩type外类比时改为Default,因为这俩只是描述mv实虚并非fo类型; |
| BUG6 | 有时R取到dsFo解决方案,却又指向实mv `T`; |
|  | > 查应该是BUG5不区分Diff和Same,导致原本虚Fo防重无效,重赋值成实fo; |
|  | > 方案: 将BUG5改成不区分ATSame,但区分ATDiff; |

| 24023 | 训练步骤整理 | 训练目标 |
| --- | --- | --- |
| FZ26-1 | 边直击边飞至左下 | 被撞和不被撞经验,GL经验 |
| FZ26-2 | 边直击边飞至右上 | 被撞和不被撞经验,GL经验 |
| FZ26-3 | 在安全地带各处偏击10次 (危险地带下方) | 加训P经验 |
| FZ26-4 | 在危险地带各处直击10次 | 加训S经验 |
| 结果 | 训练得到FZ26 |  |

<br><br><br>

## n24p03 单元测试-自检告警机制
`CreateTime 2021.09.24`

在HE的测试中,经常因为改了一小点代码,导致其影响的部分,只有后天训练时,才可能看到bug,编译期和执行前期都不会有任何问题,所以有必要在其可能影响到的代码处,或者系统运行的关键且可能出错处,做一些自检告警机制,使我们可以在出问题的时候,更及时快速的定位问题;

| 24031 | AIKVPointer集成type迭代后->告警目录 |
| --- | --- |
| 自检1 | 测下getHN经验时vDS匹配判断代码是否多余,多余告警; |
| 自检2 | 测生成GL的AIKVPointer时的ds是否正常赋值,因为它影响node防重; |
| 自检3 | 测生成非GL的AIKVPointer时的ds是否为" ",因为它影响node防重; |
| 自检4 | 行为飞稀疏码的isOut为false的问题; |
| 自检5 | 测生成GL的AIKVPointer时的at是否正常赋值,因为它影响node防重; |
| 自检6 | 测从conNodes取at&ds&type应唯一,否则查为何不同的node会类比抽象; |
| 自检7 | 测构建SPFo时,元素有两种类型的原因(参考24022BUG3) |
| 自检8 | 测构建Fo时,有不匹配type的元素原因(参考24022BUG4) |
| 自检9 | 测构建了Y距35的P节点原因(参考24057&24058) |

<br><br><br>

## n24p04 子任务迭代
`CreateTime 2021.09.28`

本节针对两个问题展开:
1. 主任务怕疼,子任务又预测到疼,父子同质 (父子同质问题,参考24041);
2. 即使喝自来水不是很干净,为了解渴我也喝了 (pk池迭代,参考24042);

| 24041 | 子任务与父任务同质mv问题 |
| --- | --- |
| 示图 | ![](assets/537_父子同质问题.png) |
| 说明 | 如图,主任务和子任务都是疼任务,而这样的繁琐嵌套许多许多次发生; |
| 复现 | `FZ26,右上飞,直击` |
| 举例 | 累了`{累-9}`想喝水,买水跑路也很累`{累-5}`; |
| 方案1 | status新增pk`竞争状态`,反思流程`转至24042`; |
|  | 分析: 示图套入24042流程,F493子任务仍会形成并行为化,并不解决此问题; |
| 方案2 | 跑路累就考虑是否可解决,比如让外面朋友帮忙稍回来一瓶; |
|  | 分析: 此条本来就是现在的做法,无需要代码改动; |
| 结果 | 方案1无效,方案2认为当前本来就没问题,采纳方案2,不用改; |

**24042-子任务决策流程: pk池迭代计划**
1. 反思评分>=0时,直接继续行为化 (即以往的反思通过);
2. 反思评分<0时,形成子任务 (即以往子任务);
   - 当limit条全<0时,形成子任务,并尝试`规划决策`;
     - 第1条为去买水累`{-5}`;
       - 能不能避免跑路买水?答案不能,还是-5,加入pk池;
     - 第2条为喝自来水`{-10}`;
       - 能不能自来水变干净,答案能,烧开即可好许多,变成-1,加入pk池;
     - 第3条为喝过期水`{-20}`;
       - 能不能过期水加工?答案不能,还是-20;
     - 第4条为喝冰箱可乐会肚子痛`{-25}`;
       - 能不能加热,答案能,烧开即可,变成0,直接执行;
   - 对子任务`规划决策`后,有如下几种可能:
     - `评分 < 0 && 评分 > 主任务-9`,则加入pk池 (如第1,2条);
     - `评分 < 0 && 评分 <= 主任务-9`,则直接失败 (如第3条);
     - `评分 >= 0`,则直接执行 (如第4条);
   - 当没有`第4条`时,则对第1,2条进行pk排序,排序后,第2条为-1,优先执行;
3. 结果: 对于目前的乌鸦训练来说,pk池需求并不迫切;
   - 因为目前R任务的ds解决方案只有mv0,不可能变成-1这种值,所以此迭代`暂停`;

<br><br><br>

## n24p05 十二测:继续进行GL相关测试训练
`CreateTime 2021.09.29`

在十一测中,最后在getGL经验上有了互相空S掉的混乱BUG,在n24p02中进行了节点类型大排查后,重新训练了FZ26,现在回归测试,进行十二测;

| 24051 | FZ26回测-危险地带Y距在PM中评价通过的问题 |
| --- | --- |
| 复现 | `FZ26,直击` |
| 说明 | 发现日志中,Y距的S要么是0条,要么即使不是0条也没有P评分大,导致通过; |
| 分析 | 从FZ26-4日志可见,在危险地带有多次被乌鸦躲开没撞到,导致S经验不足; |
| 方案 | 尝试对FZ26-4进行加训,危险地带多撞几次,习得更多S经验; |
| 结果 | 危险地带多撞失败,它每次都躲飞到下方安全地带,改为重训FZ27,转24052; |

| 24052 | 训练步骤整理 | 训练目标 |
| --- | --- | --- |
| FZ26-1 | 边直击边飞至左下 | 被撞和不被撞经验,GL经验 |
| FZ26-2 | 边直击边飞至右上 | 被撞和不被撞经验,GL经验 |
| FZ27-3 | 在危险地带各处直击10次 | 加训S经验 |
| FZ27-4 | 在安全地带各处偏击10次 (危险地带下方) | 加训P经验 |
| 结果 | 训练得到FZ27 |  |

| 24053 | FZ27回测-危险地带Y距在PM中评价通过的问题2 |
| --- | --- |
| 简写 | `1.rMatchFo=R任务预测源`,`2.前期=指IRT时期`,`3.后期=指ORT时期`; |
| 复现 | `FZ27,直击` |
| 回测 | 问题依旧,S经验不足,但可以顺利加训S了,但加训后,S依然不足; |
| 分析 | 怀疑dsFo进入PM时,毕竟dsFo本就是解决方案,自然P(顺)多S(逆)少; |
| 分析 | 尝试将rMatchFo.SP加入PM分析中,因为它预测生成任务,自然S多P少; |
| 调试 | 1.代码: 从生成SP代码处,分析SP的baseFo来源; |
|  | > IRT从matchPFos预测而来,即从指向了mv的Normal节点; |
|  | > ORT从actYes反省而来,即hngl和dsFo和p+模式的Fo三种都有可能触发; |
|  | 结果1: dsFo的SP依赖后期,因为ORT的第2种是它,而IRT没它; |
|  | 结果2: rMatchFo的SP依赖前期,因为IRT有它,而ORT中没它(因它指向-mv); |
|  | 结果3: pMatchFo的SP前后期都有,IRT有它,ORT也有(因它指向+mv); |
| 调试 | 2.数据: 调试rMatchFo的SP数,看是否与预期相符,前期有较多SP; |
|  | 结果1: 发现rMatchFo的SP虽然不少,但没一条是与当前评价稀疏码同区的; |
|  | 继续查: IRT的SP由protoFo-matchFo得来,应该有同区码才对; |
| 白话 | dsFo.SP表示: 当前解决,方案内,怎样较好; |
|  | 例如: 这个变向,需要更快速度,使变向动作`本身得到更好效果`; |
|  | rMatchFo.SP表示: 当前场景,方案外,怎样较好; |
|  | 例如: 这个变向,需要更大幅度,使变身动作`能够闪开面前大壮`; |
| 原因 | 现R任务对dsFo进行PM时,它是后期SP,所以很难取到足够的SP供评价; |
| 求解 | 所以在PM中,仅靠dsFo.SP是不够的,想办法将IRT也加入进来很重要; |
| 方案 | 发R模式将dsFo传入PM时,补充将rMatchFo.SP也作用于评价; |
| 实践 | 1. pm_GetValidSPAlg_ps()取rMatchFo的SP(直接absPorts取即可) T |
|  | 2. AIScore.VRS()中,支持demand传入,并对rMatchFo进行评分; T |
|  | 3. AIScore.score4Value()中,兼容支持rMatchFo时的评分; T |
|  | 4. 在AIScore.VRS()中,支持将rMatchFo的评分作用于评价; T |
|  | 5. 在PM()中,支持从rMatchFo.SP取最近的p做修正目标; T |
| TODO | 1. 对P模式的matchFo的SP也要作用于评价 `随后重回觅食训练时,再支持`; |
|  | > 因为P模式也有导致任务的matchFo,只是它现在没保留到pDemand中; |
|  | 2. 考虑将PM中P最近的mostSimilarAlg废弃掉,而转为采用强度最强的; |
|  | > 因为直接取mostSimilar与自由竞争相违背,不改先,后有时间再改; |
|  | 3. 为避免VRS束波求和SP数多者占优,考虑将平均作用力也作用其中; |
|  | > tips:加入平均作用力是否有新的不公呢? `考虑明白后再实践` |
| 结果 | 实践5条全完成,按FZ27的步骤重训得到FZ29 (回测转24057); |

| 24054 | 24053改动回测-SP定义混乱 |
| --- | --- |
| BUG | Y距35明明在危险地带,它的P强度却为12,导致Y距35被VRS误评价为通过; |
| 复现 | FZ27,直击 `baseFo:F278[A277(Y距35)]` |
| 怀疑 | 在学时,顺逆与好坏不匹配,导致BUG,查FZ27日志如下; |
|  | 1. 在ORT中,所有的顺逆与好坏是匹配的 (顺时好,逆时坏); |
|  | 2. 在IRT中,顺逆和好坏有时是不匹配的 (预测坏,结果坏,这很顺但坏); |
|  | 本质: 本问题本质在于,SP表示的是顺逆,还是好坏; |
| 方案1 | 从代码定义清晰原则(理性数据的顺逆不表示好坏),应定义为`顺逆`; |
|  | > 顺逆则学简用繁 (学时只判断是否顺利,用时判断好坏再评分); |
| 方案2 | 从SP数据的作用: 直观,易理解,且方便使用则应定为`好坏` |
|  | > 好坏则学繁用简 (学时需判断是好是坏,用时直接取出即评分); |
| 选择 | 此次bug即因SP定义为顺逆,但VRS评价中当好坏来用了,所以选方案2; |
| 实践 | 将SP定义为好坏,并在IRT的反省触发处,改为好坏判断; |
| 回测 | 重训FZ27得FZ28,然后`FZ28,直击`,发现Y距35评价为不通过ok; |

| 24055 | 24053改动回测-PM行为修正过期后还构建SP |
| --- | --- |
| 说明 | 此BUG只是因24054的BUG,而怀疑有,但未证实; |
| 导致 | 它会导致Y距35被VRS误评价为通过; |
| 怀疑 | 明明已躲开,Y距35已失效,还按Y距35反省为P,应以最新Y距为准; |
| 结果 | 已证实24054怀疑成立,先改24054,此处暂停,后有问题再继续; |

| 24056 | 24053&24054实践全完成回训 | 训练目标 |
| --- | --- | --- |
| 1 | 边直击边飞至左下 | 被撞和不被撞经验,GL经验 |
| 2 | 边直击边飞至右上 | 被撞和不被撞经验,GL经验 |
| 3 | 在危险地带各处直击5次 | 加训S经验 |
| 4 | 在安全地带各处偏击5次 (危险地带下方) | 加训P经验 |
| 结果 | 训练得到FZ29 |  |

| 24057 | FZ29回测-Y距35有P经验问题-主客观时间线不统一导致认知偏差 |
| --- | --- |
| 原则1 | 不要试图像主客观世界时间线统一,人类忙时也对外界感知弱,导致认知偏差; |
| 原则2 | 因时间认知偏差,难免会无法或错认某事,在竞争中消除影响即可 (误会); |
| BUG | `FZ29,直击`发现24054的BUG还是存在 |
| 示图 | ![](assets/538_FZ29回测到Y距35的P_IRT评分太高问题.png) |
| 调试 | ![](assets/539_卡主线程导致触发器不准时的问题.png) |
| 说明 | 1. 如图,`FZ29-2,直击`后,先形成了IRT触发器预测 (0.93s); |
|  | 2. 然后R任务一直卡着嵌套子任务 (用时2s); |
|  | 3. 当不卡后,UI反应过来扔出木棒时,IRT触发器已经触发了; |
| 问题 | 子任务反思循环卡着,导致触发器触发不准时,导致误判为P; |
| 方案1 | **当主线程卡住时,使触发器触发时间顺延 `5%` `废弃`;** |
|  | 说明: 简单偷懒方案: 主线程卡住时,触发器时间顺延等待,卡的时间不算数; |
|  | 否掉: 卡住状态是没法精确判断的,所以这种顺延没法实现; |
| 方案2 | **现实世界不等人,使思维控制不应占用UI线程 `可行` `T`;** |
|  | 分析: 此方案需结合方案3,不然TC还卡着,UI却撞死乌鸦了; |
|  | 结果: TOR决策模式异步时,与主线程训练日志打的比较乱,暂先关掉; |
| 方案3 | **非紧急情况才反思,避免UI紧急TC却卡着 `可行` `T`** |
|  | 情况1: 紧急=>例如为躲糜鹿,车撞护栏 |
|  | --> 在行为输出前,来不急思考过多,导致撞护栏,没来的及反思; |
|  | 情况2: 非紧急=>例如前方地上有塑料袋,变道前,看有没后车; |
|  | --> 在行为输出前,即意识到变道危险,所以是反思无疑; |
|  | 综上: 反思与否,应看情况紧急程度,现实世界可不等人; |
|  | 实践: 暂定为,当预测发生时间<30s时,不进行反思子任务; |
| 方案4 | **避免太多反思子任务循环 `5%` `废弃`;** |
|  | 分析: 以往已经做过子任务不应期防重等,强行限制循环数不可取 `废弃`; |
| 方案5 | **原则2错误SP难免,抽象时初始强度改为1,而非继承具象 `95%` `T`** |
|  | 分析: 无论此问题是否解决,此方案执行后,一定程度有效防止VRS误评价; |
| 分析 | 分析后:14方案不可取`5%`,23方案可实践试下`50%`,5方案必执行`95%`; |
| 结果 | 235方案改完(2关,35开),方案2治标不治本,且目前使TC不卡不太可能; |
| 转移 | 当前Demo和内核在同一项目跑,一卡就会互相有所影响,此无解,转24058 |

| 24058 | 主客观时间不统一之: 同项目下主客观互卡问题 |
| --- | --- |
| 问题1 | 智能体`紧急状态`导致对外界信息`不及多想` (已ok,参考24057-方案3) |
| 问题2 | 智能体`卡顿走神`导致对外界信息`没注意到` (目前会迟或早,但全能收到) |
| 简介 | 问题1在24057已ok,本表重点解决问题2,即外界信息时迟时早的问题; |
| 示图 | ![](assets/540_主客观时间不统一之外界时迟时早问题.png) |
| 如图 | 主客观互卡无解,但可先整理下UI触发时机,使TC可顺利跑先; |
| 结果 | 方案1执行完成,重新训练FZ30,仅训练到第2步发现BUG,转24059; |

| 24059 | 被撞前飞行为导致多次预测的情况分析 |
| --- | --- |
| 复现 | `FZ30-1,直击`,发现在撞到前,小鸟多次行为化自行飞行输出; |
| 问题 | 每次飞导致小鸟再次看到木棒,预测同样的危险,并且重新构建IRT触发器; |
| 问题 | 同时,因为多次飞R决策不断卡住,导致IRT触发有误,Y距35触发了P; |
| 示例 | 当车追车鸟撞,鸟边逃边回头看车3次,识别预测构建IRT触发器各3次,那么: |
| 方案1 | 3次看,当前场景F不变,位置Y距35变了,旧帧的IRT触发器应失效; |
|  | 分析: IRT需加上理性失效,如:Y距35被加工成Y距38,原本的触发器应失效; |
| 方案2 | 3次看,3个IRT都是独立的,即使最终S撞到了,前面的IRT也已熬到P结束了; |
|  | > 如果这条ok,那么当前的多次IRT,前面熬到产生P的Y距35是正常的,但:↓ |
|  | > 反例: 车撞来总能躲开(P),终导致VRS评价Y距35通过,从而放弃躲避; |
|  | > 结果: 有能力解决问题,不表示问题不存在,`此条否掉`; |
| 结果 | 选用方案1,实践`转n24p06`; |


<br><br><br>

## n24p06 IRT的理性失效
`CreateTime 2021.10.17`

| 24061 | IRT的理性失效代码实践 |
| --- | --- |
| 起因 | 参考24059-原预测等待中的IRT,可能新帧会对场景推进变化,导致它应失效 |
| 方案1 | 只会失效一部分V,而非整个F,所以到IRT类比时再判断哪些V失效; |
|  | > 此方案脱离场景F,有违原则,所以`否掉`; |
| 方案2 | 到OPushM来实现,新增TIModel的理性判断,并更新status `T`; |
|  | > 在tir_OPushM对新protoFo与等待IRT的fo间判断mIsC,符合则等待失效; |
| 结果 | 方案2已执行,重新训练得FZ31; |

| 24062 | 回测FZ31问题1 |
| --- | --- |
| 问题 | tirOPushM新增的protoFo与waitFo判断mIsC很难成立; |
| 分析 | 随着飞行行为,时序的变化很大,看是否改为局部(时序前面的alg)mIsC匹配 |

| 24063 | 回测FZ31问题2 |
| --- | --- |
| 问题 | 左飞时刚好撞到木棒,后才识别左飞,导致认为左飞后没疼,反省为P; |
| 分析 | `FZ31-1,直投`,发现第二次自行左飞时,刚好撞到木棒,流程图分析如下: |

| 24064 | 回测FZ31问题3->PM中修正目标与原值一致问题 |
| --- | --- |
| 问题 | `FZ31,直击`,PM中Y距35评价不通过正常,但修正目标一样导致不行为化; |
| 如图 | ![](assets/541_FZ31回测_Y距35有P所以PM中判断为不必修正.png) |
| 分析 | 1. Y距35难免会有P,比如已经飞过去的,在这个位置没危险: |
|  | 2. 但取Y距35为修正目标有错,此BUG关键:修正目标取值太广不理性; |
| 出路 | 要么预测当前没危险,不进行反省 (广入原则,所以必须进行反省) `否掉`; |
| 结果 | 修正目标太广不理性,这个就要涉及到大的迭代了 `转n24p07`; |


<br><br><br>

## n24p07 PM迭代V4-稳定性判断 (理性迭代)
`CreateTime 2021.10.19`

转自24064,原问题为:在PM中Y距35修正目标也是Y距35,导致不必修正,而Y距35难免会有P(比如,右侧已飞过的木棒不危险,从而反省出P),而PM又是针对所有pPorts取最近的P为修正目标的,那么此取值方式太广不够理性,本节将针对这一问题进行PM更理性迭代;

在以往的做法中,指导性做的到位,但稳定性做的不到位,导致`指导性和稳定性`这两个兄弟协作的不是很好,本次迭代主要针对稳定性判断迭代之,使之理加理性,结果更好;

| 24071 | PM迭代V4: 更理性 |
| --- | --- |
| 线索 | 稳定时序为:`[Y距35,左向木棒]->{危险}`,所以从稳定性分析出发,如下图: |
|  | ![](assets/542_PM迭代V4_找出稳定的GL目标.png) |
| 如图 | PM从F1出发,向性下找到稳定P的F为止 (左侧以F6为止,右侧以F3为止); |
| 分析 | 1. 当V为Y距时,它多变,具象很多:如F4F5F6F7F8等,它们可能同层多个稳定; |
|  | 2. 当V为向时,它值少,具象很少:如F2F3,它们可能同层很少个稳定(F3); |
|  | 结论: 无论V变化多少,此处工作方式,都是向性下,找出稳定节点; |
| 扩展 | 1. 左右向木棒,识别为两个不同场景; |
|  | 答: 可行,即取到的F1本就更稳定些,但依然得向下找稳定F; |
|  | 2. 从F1出发,找Y距稳定时,会不会找到F3并中止? |
|  | 答: 所以当F3不包含Y距同区码时,需要判断它是否包含在rFos&pFos中; |
|  | 即: 仅从rFos&pFos的最具象出发,避免分支F3与protoFo无抽具象关系; |
| 结果 | 关键在于稳定性上的迭代,以及稳定性与指导性的协作上; |

| 24072 | 代码实践: 分析改什么不改什么 |
| --- | --- |
| PM算法 | PM对独特码逐一评价,失败时,继续尝试下一条,全失败时才失败; |
| 单码评分 | 1. 取消束波求和,因为SP不再描述具体稀疏码值,束波求和不需要了; |
|  | 2. VRS评价不再依赖束波求和,而是依赖F下的`SP强度`做稳定性判断; |
|  | 结果: 参考SP表征结果,SP的具体码描述不可取消,束波求和也无法废弃; |
| 多码协同 | 无论多少个码,每个都很多变,都依下面同样的代码规则跑; |
|  | 问题: 如果一个码几乎不重复,那么SPStrong就永远只有1或0,怎么办? |
|  | 分析: 比如苹果在手边,什么距离算手边?这样的概念如何形成? |
|  | 如: F1:`[伸手,可及]`的映射,即老早以前提过的时序的概念化; |
|  | > F1不包含距离,它仅表征伸手动作可得到的结果,它的具象fo才有距离; |
|  | > 方案1: 采用from-to,缺点是无法表达各点强度,范围太广时评价不准确; |
|  | > 方案2: 还是采用束波求和,对最终SP及其强度进行计算得出结果 `95%`; |
|  | 结果: 最终答案还是束波求和; |
| SP表征 | 1. IRT表征感性SPPerceptStrong,而ORT表征理性SPReasonStrong; |
|  | > SP仅对自己打分,即仅在fo中表征`感理性spStrong`四个值即可; |
|  | > 将sp两个Strong封装新的AIMvPort,fo指向mvPorts使用 (暂不做); |
|  | > SP仅描述`好坏`两个强度值,不再描述具体的稀疏码值; |
|  | > 抽象F的SP不再具体描述它不包含的V值; |
|  | > 比如:F1就仅描述自己SP,F2也是仅描述左向SP,不描述Y距的; |
|  | 结果: 当SP仅针对节点中一部分元素呢?所以不描述具体的码不可行; |
| 初始强度 | 具象SP初始为1,抽象SP初始强度为具象之和; |
|  | 结果: 刚改成抽象SP初始强度为1 `参考24057-方案5`; |
| 应用联想 | 从所有rFos&pFos出发(含自身),向具象找稳定SP; |
|  | 问: 如何防止找到F3这种叉枝,做为"稳定"结果? |
|  | 答: 从`准确性`判断,解决这种错叉枝导致失准问题:`即rFos&pFos包含判断`; |
|  | 结果1: 从`指导性`负责准确,`稳定性`负责评价,协作做出正确解; |
|  | 结果2: 空S评价,也要跟着改动,考虑废弃它,因为抽象切入不负责稳定性; |

| 24073 | 代码实践: 实践条目 |
| --- | --- |
| 示图 | ![](assets/542_PM迭代V4_找出稳定的GL目标.png) |
| 1 | PM对独特码逐一评价,失败时,继续尝试下一条,全失败时才失败; |
| 2 | 从所有rFos&pFos出发,负责指导性 (准确性,如当前是F2还是F3); |
| 3 | 向具象筛选出稳定SP,并对稳定的SPPorts进行`束波求和评分&VRS评价`; |
| 4 | 空S评价,也要跟着改动,考虑废弃它,因为抽象切入不负责稳定性; |


<br><br><br><br><br>
